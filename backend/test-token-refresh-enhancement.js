const axios = require('axios');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\nconst API_BASE_URL = process.env.API_URL || 'http://localhost:3001';\n\n// Test configuration\nconst TEST_CONFIG = {\n  username: 'testchild',\n  pin: '1234',\n  parentEmail: 'testparent@example.com',\n  parentPassword: 'testpassword123'\n};\n\nclass TokenRefreshTester {\n  constructor() {\n    this.tokens = null;\n    this.testResults = [];\n  }\n\n  log(message, type = 'INFO') {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${type}: ${message}`;\n    console.log(logMessage);\n  }\n\n  addResult(testName, success, message, data = null) {\n    const result = {\n      testName,\n      success,\n      message,\n      data,\n      timestamp: new Date().toISOString()\n    };\n    \n    this.testResults.push(result);\n    this.log(`${testName}: ${success ? 'PASS' : 'FAIL'} - ${message}`, success ? 'PASS' : 'FAIL');\n    \n    if (data) {\n      this.log(`Test data: ${JSON.stringify(data, null, 2)}`);\n    }\n  }\n\n  async makeRequest(endpoint, options = {}) {\n    const url = `${API_BASE_URL}${endpoint}`;\n    \n    const config = {\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      ...options\n    };\n\n    // Add auth token if available\n    if (this.tokens?.accessToken) {\n      config.headers.Authorization = `Bearer ${this.tokens.accessToken}`;\n    }\n\n    this.log(`Making request: ${options.method || 'GET'} ${url}`);\n    \n    try {\n      const response = await axios(url, config);\n      this.log(`Response: ${response.status} ${response.statusText}`);\n      return response.data;\n    } catch (error) {\n      this.log(`Request failed: ${error.message}`, 'ERROR');\n      if (error.response) {\n        this.log(`Error response: ${error.response.status} - ${JSON.stringify(error.response.data)}`, 'ERROR');\n      }\n      throw error;\n    }\n  }\n\n  async testChildLogin() {\n    this.log('=== Testing Child Login ===');\n    \n    try {\n      const loginData = await this.makeRequest('/auth/child/login-legacy', {\n        method: 'POST',\n        data: {\n          username: TEST_CONFIG.username,\n          pin: TEST_CONFIG.pin\n        }\n      });\n\n      // Validate response structure\n      const requiredFields = ['user', 'accessToken', 'refreshToken'];\n      const missingFields = requiredFields.filter(field => !loginData[field]);\n      \n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Store tokens for subsequent tests\n      this.tokens = {\n        accessToken: loginData.accessToken,\n        refreshToken: loginData.refreshToken,\n        user: loginData.user\n      };\n\n      this.addResult('Child Login', true, 'Child login successful', {\n        userId: loginData.user.id,\n        username: loginData.user.username,\n        role: loginData.user.role,\n        hasSessionId: !!loginData.sessionId\n      });\n      \n      return loginData;\n    } catch (error) {\n      this.addResult('Child Login', false, `Child login failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testParentLogin() {\n    this.log('=== Testing Parent Login ===');\n    \n    try {\n      const loginData = await this.makeRequest('/auth/login', {\n        method: 'POST',\n        data: {\n          email: TEST_CONFIG.parentEmail,\n          password: TEST_CONFIG.parentPassword\n        }\n      });\n\n      // Validate response structure\n      const requiredFields = ['user', 'accessToken', 'refreshToken'];\n      const missingFields = requiredFields.filter(field => !loginData[field]);\n      \n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      this.addResult('Parent Login', true, 'Parent login successful', {\n        userId: loginData.user.id,\n        email: loginData.user.email,\n        role: loginData.user.role\n      });\n      \n      return loginData;\n    } catch (error) {\n      this.addResult('Parent Login', false, `Parent login failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testTokenRefresh(userType = 'child') {\n    this.log(`=== Testing ${userType} Token Refresh ===`);\n    \n    if (!this.tokens?.refreshToken) {\n      throw new Error('No refresh token available. Please login first.');\n    }\n\n    try {\n      const refreshData = await this.makeRequest('/auth/refresh', {\n        method: 'POST',\n        data: {\n          refreshToken: this.tokens.refreshToken\n        }\n      });\n\n      // Validate response structure\n      const requiredFields = ['accessToken', 'refreshToken', 'user'];\n      const missingFields = requiredFields.filter(field => !refreshData[field]);\n      \n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Verify user role consistency\n      if (userType === 'child' && refreshData.user.role !== 'CHILD') {\n        throw new Error(`Expected CHILD role, got ${refreshData.user.role}`);\n      }\n      \n      if (userType === 'parent' && refreshData.user.role !== 'PARENT') {\n        throw new Error(`Expected PARENT role, got ${refreshData.user.role}`);\n      }\n\n      // Update stored tokens\n      const oldTokens = { ...this.tokens };\n      this.tokens = {\n        accessToken: refreshData.accessToken,\n        refreshToken: refreshData.refreshToken,\n        user: refreshData.user\n      };\n\n      // Verify tokens are different (new tokens issued)\n      const tokensChanged = (\n        oldTokens.accessToken !== refreshData.accessToken ||\n        oldTokens.refreshToken !== refreshData.refreshToken\n      );\n\n      this.addResult(`${userType} Token Refresh`, true, 'Token refresh successful', {\n        tokensChanged,\n        userRole: refreshData.user.role,\n        hasSessionId: !!refreshData.sessionId,\n        expiresIn: refreshData.expiresIn\n      });\n      \n      return refreshData;\n    } catch (error) {\n      this.addResult(`${userType} Token Refresh`, false, `Token refresh failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testTokenRefreshWithExpiredToken() {\n    this.log('=== Testing Token Refresh with Expired Token ===');\n    \n    try {\n      // Use a fake expired token\n      const fakeExpiredToken = 'expired_token_12345';\n      \n      await this.makeRequest('/auth/refresh', {\n        method: 'POST',\n        data: {\n          refreshToken: fakeExpiredToken\n        }\n      });\n      \n      // Should not reach here\n      this.addResult('Expired Token Refresh', false, 'Expired token was accepted (security issue)');\n    } catch (error) {\n      if (error.response?.status === 401) {\n        this.addResult('Expired Token Refresh', true, 'Expired token properly rejected');\n      } else {\n        this.addResult('Expired Token Refresh', false, `Unexpected error: ${error.message}`);\n      }\n    }\n  }\n\n  async testTokenRefreshErrorHandling() {\n    this.log('=== Testing Token Refresh Error Handling ===');\n    \n    const testCases = [\n      {\n        name: 'Invalid Token Format',\n        token: 'invalid_token',\n        expectedStatus: 401\n      },\n      {\n        name: 'Empty Token',\n        token: '',\n        expectedStatus: 400\n      },\n      {\n        name: 'Null Token',\n        token: null,\n        expectedStatus: 400\n      }\n    ];\n\n    for (const testCase of testCases) {\n      try {\n        await this.makeRequest('/auth/refresh', {\n          method: 'POST',\n          data: {\n            refreshToken: testCase.token\n          }\n        });\n        \n        this.addResult(`Error Handling - ${testCase.name}`, false, 'Invalid token was accepted');\n      } catch (error) {\n        const actualStatus = error.response?.status;\n        const success = actualStatus === testCase.expectedStatus || (actualStatus >= 400 && actualStatus < 500);\n        \n        this.addResult(\n          `Error Handling - ${testCase.name}`, \n          success, \n          `Expected 4xx error, got ${actualStatus}`\n        );\n      }\n    }\n  }\n\n  async testCrossUserTokenRefresh() {\n    this.log('=== Testing Cross-User Token Refresh Security ===');\n    \n    try {\n      // First login as child\n      const childLogin = await this.testChildLogin();\n      const childRefreshToken = childLogin.refreshToken;\n      \n      // Then login as parent\n      const parentLogin = await this.testParentLogin();\n      \n      // Try to use child refresh token while logged in as parent\n      try {\n        await this.makeRequest('/auth/refresh', {\n          method: 'POST',\n          data: {\n            refreshToken: childRefreshToken\n          }\n        });\n        \n        this.addResult('Cross-User Token Security', false, 'Cross-user token refresh was allowed (security issue)');\n      } catch (error) {\n        if (error.response?.status === 401 || error.response?.status === 403) {\n          this.addResult('Cross-User Token Security', true, 'Cross-user token refresh properly blocked');\n        } else {\n          this.addResult('Cross-User Token Security', false, `Unexpected error: ${error.message}`);\n        }\n      }\n    } catch (error) {\n      this.addResult('Cross-User Token Security', false, `Test setup failed: ${error.message}`);\n    }\n  }\n\n  async runAllTests() {\n    this.log('=== Starting Enhanced Token Refresh Tests ===');\n    \n    try {\n      // Test child authentication and token refresh\n      await this.testChildLogin();\n      await this.testTokenRefresh('child');\n      \n      // Test multiple refresh cycles\n      await this.testTokenRefresh('child');\n      await this.testTokenRefresh('child');\n      \n      // Test parent authentication and token refresh\n      await this.testParentLogin();\n      await this.testTokenRefresh('parent');\n      \n      // Test error handling\n      await this.testTokenRefreshWithExpiredToken();\n      await this.testTokenRefreshErrorHandling();\n      \n      // Test security\n      await this.testCrossUserTokenRefresh();\n      \n      this.log('=== All Tests Completed ===');\n      this.printSummary();\n      \n    } catch (error) {\n      this.log(`Test suite failed: ${error.message}`, 'ERROR');\n      this.printSummary();\n      process.exit(1);\n    } finally {\n      await prisma.$disconnect();\n    }\n  }\n\n  printSummary() {\n    this.log('=== Test Summary ===');\n    \n    const totalTests = this.testResults.length;\n    const passedTests = this.testResults.filter(r => r.success).length;\n    const failedTests = totalTests - passedTests;\n    \n    this.log(`Total Tests: ${totalTests}`);\n    this.log(`Passed: ${passedTests}`);\n    this.log(`Failed: ${failedTests}`);\n    this.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);\n    \n    if (failedTests > 0) {\n      this.log('\\nFailed Tests:');\n      this.testResults\n        .filter(r => !r.success)\n        .forEach(r => {\n          this.log(`  - ${r.testName}: ${r.message}`);\n        });\n    }\n    \n    this.log('\\nDetailed Results:');\n    this.testResults.forEach(r => {\n      this.log(`  ${r.success ? '✅' : '❌'} ${r.testName}: ${r.message}`);\n    });\n  }\n}\n\n// Run tests if this file is executed directly\nif (require.main === module) {\n  const tester = new TokenRefreshTester();\n  tester.runAllTests().catch(error => {\n    console.error('Test execution failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = TokenRefreshTester;"