const axios = require('axios');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\nconst API_BASE_URL = process.env.API_URL || 'http://localhost:3001';\n\n// Test configuration\nconst TEST_CONFIG = {\n  username: 'testchild',\n  pin: '1234',\n  parentEmail: 'testparent@example.com',\n  parentPassword: 'testpassword123'\n};\n\nclass ChildAuthFixTester {\n  constructor() {\n    this.tokens = null;\n    this.testResults = [];\n  }\n\n  log(message, type = 'INFO') {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${type}: ${message}`;\n    console.log(logMessage);\n    \n    if (type === 'ERROR') {\n      console.error(logMessage);\n    }\n  }\n\n  addResult(testName, success, message, data = null) {\n    const result = {\n      testName,\n      success,\n      message,\n      data,\n      timestamp: new Date().toISOString()\n    };\n    \n    this.testResults.push(result);\n    this.log(`${testName}: ${success ? 'PASS' : 'FAIL'} - ${message}`, success ? 'PASS' : 'FAIL');\n    \n    if (data) {\n      this.log(`Test data: ${JSON.stringify(data, null, 2)}`);\n    }\n  }\n\n  async makeRequest(endpoint, options = {}) {\n    const url = `${API_BASE_URL}${endpoint}`;\n    \n    const config = {\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      ...options\n    };\n\n    // Add auth token if available\n    if (this.tokens?.accessToken) {\n      config.headers.Authorization = `Bearer ${this.tokens.accessToken}`;\n    }\n\n    this.log(`Making request: ${options.method || 'GET'} ${url}`);\n    \n    try {\n      const response = await axios(url, config);\n      this.log(`Response: ${response.status} ${response.statusText}`);\n      return response.data;\n    } catch (error) {\n      this.log(`Request failed: ${error.message}`, 'ERROR');\n      if (error.response) {\n        this.log(`Error response: ${error.response.status} - ${JSON.stringify(error.response.data)}`, 'ERROR');\n      }\n      throw error;\n    }\n  }\n\n  async setupTestData() {\n    this.log('=== Setting up test data ===');\n    \n    try {\n      // Check if test parent exists\n      let testParent = await prisma.user.findUnique({\n        where: { email: TEST_CONFIG.parentEmail }\n      });\n\n      if (!testParent) {\n        this.log('Creating test parent user...');\n        const bcrypt = require('bcryptjs');\n        const hashedPassword = await bcrypt.hash(TEST_CONFIG.parentPassword, 12);\n        \n        testParent = await prisma.user.create({\n          data: {\n            firstName: 'Test',\n            lastName: 'Parent',\n            email: TEST_CONFIG.parentEmail,\n            password: hashedPassword,\n            isEmailVerified: true\n          }\n        });\n        this.log(`Created test parent: ${testParent.id}`);\n      } else {\n        this.log(`Test parent exists: ${testParent.id}`);\n      }\n\n      // Check if test child exists\n      let testChild = await prisma.child.findFirst({\n        where: { \n          username: TEST_CONFIG.username,\n          parentId: testParent.id\n        }\n      });\n\n      if (!testChild) {\n        this.log('Creating test child...');\n        const bcrypt = require('bcryptjs');\n        const hashedPin = await bcrypt.hash(TEST_CONFIG.pin, 12);\n        \n        testChild = await prisma.child.create({\n          data: {\n            username: TEST_CONFIG.username,\n            name: 'Test Child',\n            pin: hashedPin,\n            parentId: testParent.id,\n            age: 10,\n            grade: '5th',\n            isActive: true\n          }\n        });\n        this.log(`Created test child: ${testChild.id}`);\n      } else {\n        this.log(`Test child exists: ${testChild.id}`);\n        \n        // Ensure child is active\n        if (!testChild.isActive) {\n          await prisma.child.update({\n            where: { id: testChild.id },\n            data: { isActive: true }\n          });\n          this.log('Activated test child');\n        }\n      }\n\n      this.addResult('Setup Test Data', true, 'Test data setup completed', {\n        parentId: testParent.id,\n        childId: testChild.id\n      });\n      \n      return { testParent, testChild };\n    } catch (error) {\n      this.addResult('Setup Test Data', false, `Failed to setup test data: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testChildLogin() {\n    this.log('=== Testing Child Login ===');\n    \n    try {\n      // Test legacy endpoint first\n      this.log('Testing legacy child login endpoint...');\n      const loginData = await this.makeRequest('/auth/child/login-legacy', {\n        method: 'POST',\n        data: {\n          username: TEST_CONFIG.username,\n          pin: TEST_CONFIG.pin\n        }\n      });\n\n      // Validate response structure\n      const requiredFields = ['user', 'accessToken', 'refreshToken'];\n      const missingFields = requiredFields.filter(field => !loginData[field]);\n      \n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Validate user data\n      if (loginData.user.role !== 'CHILD') {\n        throw new Error(`Expected user role 'CHILD', got '${loginData.user.role}'`);\n      }\n\n      if (loginData.user.username !== TEST_CONFIG.username) {\n        throw new Error(`Expected username '${TEST_CONFIG.username}', got '${loginData.user.username}'`);\n      }\n\n      // Store tokens for subsequent tests\n      this.tokens = {\n        accessToken: loginData.accessToken,\n        refreshToken: loginData.refreshToken\n      };\n\n      this.addResult('Child Login', true, 'Child login successful', {\n        userId: loginData.user.id,\n        username: loginData.user.username,\n        role: loginData.user.role,\n        hasSessionId: !!loginData.sessionId\n      });\n      \n      return loginData;\n    } catch (error) {\n      this.addResult('Child Login', false, `Child login failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testTokenRefresh() {\n    this.log('=== Testing Token Refresh ===');\n    \n    if (!this.tokens?.refreshToken) {\n      throw new Error('No refresh token available. Please login first.');\n    }\n\n    try {\n      const refreshData = await this.makeRequest('/auth/refresh', {\n        method: 'POST',\n        data: {\n          refreshToken: this.tokens.refreshToken\n        }\n      });\n\n      // Validate response structure\n      const requiredFields = ['accessToken', 'refreshToken'];\n      const missingFields = requiredFields.filter(field => !refreshData[field]);\n      \n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);\n      }\n\n      // Update stored tokens\n      const oldTokens = { ...this.tokens };\n      this.tokens = {\n        accessToken: refreshData.accessToken,\n        refreshToken: refreshData.refreshToken\n      };\n\n      // Verify tokens are different (new tokens issued)\n      const tokensChanged = (\n        oldTokens.accessToken !== refreshData.accessToken ||\n        oldTokens.refreshToken !== refreshData.refreshToken\n      );\n\n      this.addResult('Token Refresh', true, 'Token refresh successful', {\n        tokensChanged,\n        hasUserData: !!refreshData.user,\n        userRole: refreshData.user?.role\n      });\n      \n      return refreshData;\n    } catch (error) {\n      this.addResult('Token Refresh', false, `Token refresh failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testProtectedEndpoint() {\n    this.log('=== Testing Protected Endpoint Access ===');\n    \n    if (!this.tokens?.accessToken) {\n      throw new Error('No access token available. Please login first.');\n    }\n\n    try {\n      const profileData = await this.makeRequest('/child/profile');\n      \n      // Validate profile data\n      if (!profileData.id || !profileData.username) {\n        throw new Error('Invalid profile data structure');\n      }\n\n      this.addResult('Protected Endpoint', true, 'Protected endpoint access successful', {\n        profileId: profileData.id,\n        username: profileData.username\n      });\n      \n      return profileData;\n    } catch (error) {\n      this.addResult('Protected Endpoint', false, `Protected endpoint access failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testSessionPersistence() {\n    this.log('=== Testing Session Persistence ===');\n    \n    try {\n      // Simulate page refresh by making multiple requests\n      const requests = [];\n      \n      for (let i = 0; i < 3; i++) {\n        requests.push(this.makeRequest('/child/profile'));\n      }\n      \n      const results = await Promise.all(requests);\n      \n      // Verify all requests succeeded with same user data\n      const firstResult = results[0];\n      const allSame = results.every(result => \n        result.id === firstResult.id && \n        result.username === firstResult.username\n      );\n      \n      if (!allSame) {\n        throw new Error('Inconsistent session data across requests');\n      }\n\n      this.addResult('Session Persistence', true, 'Session persistence working correctly', {\n        requestCount: results.length,\n        userId: firstResult.id\n      });\n      \n      return results;\n    } catch (error) {\n      this.addResult('Session Persistence', false, `Session persistence failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testLogout() {\n    this.log('=== Testing Logout ===');\n    \n    if (!this.tokens?.accessToken) {\n      throw new Error('No access token available. Please login first.');\n    }\n\n    try {\n      await this.makeRequest('/auth/logout', {\n        method: 'POST'\n      });\n\n      // Clear stored tokens\n      this.tokens = null;\n\n      // Verify token is no longer valid\n      try {\n        await this.makeRequest('/child/profile');\n        throw new Error('Token still valid after logout');\n      } catch (error) {\n        if (error.response?.status === 401) {\n          // Expected - token should be invalid\n          this.addResult('Logout', true, 'Logout successful - token invalidated');\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      this.addResult('Logout', false, `Logout failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async testInvalidCredentials() {\n    this.log('=== Testing Invalid Credentials ===');\n    \n    try {\n      await this.makeRequest('/auth/child/login-legacy', {\n        method: 'POST',\n        data: {\n          username: 'invaliduser',\n          pin: '9999'\n        }\n      });\n      \n      // Should not reach here\n      this.addResult('Invalid Credentials', false, 'Login succeeded with invalid credentials');\n    } catch (error) {\n      if (error.response?.status === 400 || error.response?.status === 401) {\n        this.addResult('Invalid Credentials', true, 'Invalid credentials properly rejected');\n      } else {\n        this.addResult('Invalid Credentials', false, `Unexpected error: ${error.message}`);\n      }\n    }\n  }\n\n  async runAllTests() {\n    this.log('=== Starting Child Authentication Fix Tests ===');\n    \n    try {\n      // Setup test data\n      await this.setupTestData();\n      \n      // Test invalid credentials first\n      await this.testInvalidCredentials();\n      \n      // Test valid login\n      await this.testChildLogin();\n      \n      // Test protected endpoint access\n      await this.testProtectedEndpoint();\n      \n      // Test session persistence\n      await this.testSessionPersistence();\n      \n      // Test token refresh\n      await this.testTokenRefresh();\n      \n      // Test protected endpoint with new token\n      await this.testProtectedEndpoint();\n      \n      // Test logout\n      await this.testLogout();\n      \n      this.log('=== All Tests Completed ===');\n      this.printSummary();\n      \n    } catch (error) {\n      this.log(`Test suite failed: ${error.message}`, 'ERROR');\n      this.printSummary();\n      process.exit(1);\n    } finally {\n      await prisma.$disconnect();\n    }\n  }\n\n  printSummary() {\n    this.log('=== Test Summary ===');\n    \n    const totalTests = this.testResults.length;\n    const passedTests = this.testResults.filter(r => r.success).length;\n    const failedTests = totalTests - passedTests;\n    \n    this.log(`Total Tests: ${totalTests}`);\n    this.log(`Passed: ${passedTests}`);\n    this.log(`Failed: ${failedTests}`);\n    this.log(`Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`);\n    \n    if (failedTests > 0) {\n      this.log('\\nFailed Tests:');\n      this.testResults\n        .filter(r => !r.success)\n        .forEach(r => {\n          this.log(`  - ${r.testName}: ${r.message}`);\n        });\n    }\n    \n    this.log('\\nDetailed Results:');\n    this.testResults.forEach(r => {\n      this.log(`  ${r.success ? '✅' : '❌'} ${r.testName}: ${r.message}`);\n    });\n  }\n}\n\n// Run tests if this file is executed directly\nif (require.main === module) {\n  const tester = new ChildAuthFixTester();\n  tester.runAllTests().catch(error => {\n    console.error('Test execution failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = ChildAuthFixTester;"